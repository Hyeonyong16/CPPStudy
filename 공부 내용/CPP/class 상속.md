# 클래스 상속 
## 클래스 상속이란
객체 지향 프로그래밍의 핵심 개념 중 하나

한 클래스가 다른 클래스의 속성과 메소드를 물려받아 클래스 간에 코드를 재사용할 수 있도록 한다.

## 상속의 이점
1. 코드 재사용성 - 상속을 통해 크존 클래스의 모든 멤버를 새로운 클래스에 가져올 수 있어 비슷한 기능의 새로운 클래스 생성 시 다시 작성할 필요가 없음.
2. 다형성 - 하나의 타입으로 여러 특징을 가질 수 있게 함
3. 추상화 - 부모 클래스로부터 파생되는 자식 클래스들이 구현해야 하는 함수들을 강제할 수 있으며(인터페이스), 부모 클래스를 추상화 시켜서 실제로 부모 클래스만 사용할 수 없게 만듬.

## 상속의 정의
```
class Parent
{
private:
  int m_P;

protected:
  int m_PP;
};

class Child : public Parent  // Parent를 상속 받는 Child 클래스 생성
{
private
  int m_C;
};
```
(class 클래스 명 : 접근지정자 부모클래스) 의 방식으로 클래스 상속 정의 가능

위의 코드에서 Child 는 Parent 클래스를 상속 받는 클래스 생성

### 클래스 크기
위 코드에서 Parent 클래스의 경우 int형 멤버 변수만 있으니 4바이트

Child 클래스의 경우 int형 변수만 있으나 상속받은 부모 클래스의 크기가 4바이트 > 4바이트 + 4바이트 로 총 8바이트의 크기

### 접근 지정자
상속 과정에서 부모 클래스 앞에 접근지정자를 통해 부모 클래스에서 상속받을 때 접근 범위를 지정할 수 있다.
- private : private 보다 접근 범위가 넓은 멤버를 모드 private 제한으로 바꾸어 상속
- protected : protected 보다 접근 범위가 넓은 멤버를 모드 protected 제한으로 바꾸어 상속
- public : public 보다 넓은 접근 범위가 없으므로 그대로 상속

클래스 내부 접근 지정자에도 상속에서만 쓰이는 protected 접근 지정자가 있다.
- protected
  - 상속에서만 쓰이는 접근 지정자
  - 외부에서는 해당 멤버에 접근 불가, 상속받는 자식 클래스는 접근 가능
 
## 상속에서 생성자와 소멸자
### 생성자
```
// 위 코드를 통한 기본 생성자
child()
  : m_C(0)
{
  m_PP = 1000;
};
```
상속받은 자식 클래스의 생성자를 호출할 시 해당 클래스의 부모 클래스의 생성자가 먼저 호출된다.

```
child()
 : Parent(), m_C(0)
{}

child(int _Data)
 : Parent(_Data), m_C(0)
{}
```
다음과 같이 보이진 않지만 부모 클래스 생성자가 앞에서 가장 먼저 호출이 된다.

아래부분 코드와 같이 부모 클래스 생성자를 직접 명시할 수 있다.

Parent 클래스 생성자의 위치를 뒤로 옮겨도 무조건 부모 클래스의 생성자가 먼저 호출된다.

### 소멸자
```
~Child()
{
  //Parent::~Parent();
}
```
상속받은 자식 클래스의 소멸자를 호출할 시 부모 클래스의 소멸자가 자식 클래스 소멸자 동작 후 마지막에 호출된다.

해당 과정은 컴파일러에 의해 자동으로 만들어진다.

## 오버라이딩 (Overriding)
### 오버라이딩이란?
오버라이딩 (Overriding) 이란 상속 과정에서 발생하며 부모 클래스에 구현된 멤버함수를 재정의 해서 자식 클래스에서 구현한 기능이 동작하도록 한다.

부모 클래스의 멤버함수와 이름, 반환형, 매개변수 모든게 동일해야 한다.

### 오버로딩과 차이점
- 오버로딩 (Overloading) 기존에 없던 새로운 함수를 정의
- 오버라이딩 (Overriding) 상속받은 함수의 내용만 변경

### 오버라이딩 사용
```
class Parent
{
private:
  int m_P;

public:
  void Output() { cout << m_P << endl }
};

class Child : public Parent
{
private:
  int m_C;

public:
  void Output() { cout << m_C << endl }
}

int main ()
{
  Parent p;
  Child c;

  p.Output();
  c.Output();
  c.Parent::Output();
}
```
자식 클래스에서 부모 클래스에 선언한 함수와 똑같은 함수 내용을 구현하여 자식 객체에서 해당 함수를 호출하여 사용

부모 클래스의 Output 함수가 아닌 자식 클래스에서 오버라이딩한 Output 함수로 실행된다.

오버라이딩된 함수의 부모 클래스 함수를 사용하고 싶을때는 부모클래스 범위 지정 연산자를 통해 부모 클래스 함수를 호출한다.
