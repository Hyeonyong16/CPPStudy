# 포인터
## const
```
const int data = 0;

data = 100;  // 에러 발생
```
const 의 경우 최초 한번만 값을 세팅하고 변경되지 않길 바라는 경우 사용
1. 변수 선언 시 const를 붙이면 해당 변수는 상수로 취급한다.
2. 초기화 시점에 값을 한번만 세팅할 수 있다.

## const와 포인터 활용
```
const int data = 0;
int* pInt = (int*)&data;

*pInt = 100;
```
const로 선언한 변수도 포인터로 가져오면 값을 변경 가능
1. const 변수 선언
2. 해당 변수 타입의 포인터 변수 선언
3. const 변수를 포인터 변수와 동일한 자료형으로 캐스팅
4. 값 변경

### 포인터로 const 변수 값을 바꿀 시
```
const int data = 0;
int* pInt = (int*)&data;

*pInt = 100;

printf("%d", data);    // 100이 아닌 0 출력
```
포인터를 통해 const 변수 값을 바꾼 후 printf 를 통해 출력 시 100 이 아닌 기존의 0 이 출력

컴파일러 최적화 과정에서 레지스터에는 기존의 값으로 저장되어 있는 0을 그대로 쓰기 때문 
1. **실제 주소까지 가서 값을 읽어오지 않음**
2.  컴파일러에서 자주 쓰이는 변수를 자동으로 레지스터에 저장해서 수행 속도를 높이는 최적화 기법

#### 해결법
```
volatile const int data = 0;
```
volatile의 경우 진짜 주소로 가서 값을 확인하라는 의미 (레지스터 최적화를 통해 확인 X)

## 포인터의 상수화
포인터 변수에서 const 가 붙는 위치에 따라 주소를 못바꾸게 할지, 주소에 할당된 값을 못바꾸게 할지 나뉨
### const *
```
const int* IntcPtr = nullptr;

int a = 10;
int b = 20;

IntcPtr = &a;  
IntcPtr = &b;  // 포인터로 다른 변수의 주소는 입력 가능

//*IntcPtr = 30;  // 포인터에 넣은 주소가 가르키는 곳의 값은 수정 X
```
const 가 포인터 앞 > const가 포인터를 가르킴 > 포인터의 기능을 막음
1. 포인터의 기능을 상수화 -> 주소가 가르키는 곳의 값을 수정 불가
2. 다른 변수의 주소는 입력 받기 가능

### * const
```
int a = 10;
int b = 20;

int* const IntPtrc = &a;

*IntPtrc = 30;  // 포인터에 넣은 주소가 가르키는 곳의 값 수정 가능
//IntPtrc = &b  // 포인터로 다른 변수의 주소 입력은 불가 (처음 초기화만 가능)
```
const가 변수명 앞 > const가 변수명을 가르킴 > 변수의 기능을 막겠다.
1. 포인터 변수가 상수화 -> 처음에 초기화 가능
2. 다른 변수의 주소를 입력받기 불가능.
3. 가리키고 있는 곳을 수정 가능

```
int Num = 10;
const int* const IntcPtrc = &Num;
```
둘 다 붙여서 사용도 가능. 

이 경우 앞에 두가지 성질을 전부 가짐

## 함수에 매개변수로 const
```
struct NewDataType
{
	int arr[500];
};


void OutputData(const NewDataType* _Data)
{
	// _Data를 입력받아 출력하는 함수
	for (int i = 0; i < 500; ++i)
	{
		printf("%d\n", _Data->arr[i]);
	}
}
```
함수의 매개변수로 const 및 const 포인터 사용
1. 구조체 처럼 포인터 변수보다 크기가 큰 변수를 입력 인자로 받을 때 포인터 변수로 입력을 받아 복사 비용을 줄임
2. 포인터로 받았기 때문에 원본에 접근해서 값 변경 가능 > const 선언으로 원본의 값 변경이 이루어지지 않게 함
3. const 선언을 통해 해당 변수는 데이터를 읽을 목적임을 알림
