# 클래스(class)
## 객체 지향 프로그래밍(OOP)
객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나
1. 모든 데이터를 객체로 취급, 객체가 프로그래밍의 중심이 됨
2. 각각의 객체끼리 메시지를 주고 받으며 데이터를 처리할 수 있음

### 객체 지향 프로그래밍의 특징
1. 추상화 (Abstraction)
2. 캡슐화 (Encapsulation)
3. 상속 (Inheritance)
4. 다형성 (Polymorphism)

**나중에 별도로 작성 후 링크 삽입 예정**
## 클래스란
클래스(class)란 데이터와 함수를 하나의 묶음으로 취급하는 사용자 정의 자료형

클래스 내부에는 변수와 함수가 포함되어 있음.(멤버)

객체 지향 프로그래밍은 클래스라는 개념을 통해 객체를 만들어 낸다.

### 선언 방법
```
// class 변수명 { 멤버 변수/함수 };
class MyType
{
private:
  int a;
public:
  int b;
  void SetInt(int _a) { a = _a; }
}
```
위와 같이 class 변수명으로 선언 후 멤버 변수/함수를 생성하여 선언한다.

### 접근 제한 지정자
class에서는 c언어에서의 struct와 달리 접근 제한 지정자를 통해 각 멤버에 대한 접근 레벨을 지정할 수 있다.
1. public - 어디에서든 접근이 가능한 멤버를 선언하는데 사용. 클래스 외부에서도 접근 가능
2. private - 해당 클래스의 내부에서만 접근 가능한 멤버를 선언하는데 사용. 클래스 외부에서는 접근 불가능
3. protected - 해당 클래스 및 상속받은 클래스에서만 접근 가능한 멤버를 선언하는데 사용. 해당 클래스를 상속한 하위 클래스에서는 접근 가능.

각 접근 지정자에 선언된 멤버들은 위와 같은 특징을 가진다.
### this 포인터
this 포인터란 현재 해당 객체의 주소.
```
// 위 MyType 클래스의 SetInt 함수
void SetInt(int _a)
{
  a = _a;  // this->a = _a;
}
```
위와 같이 클래스 내 해당 함수 내에서 a 앞에는 this 포인터가 생략되어있음.

this 포인터 사용 시 클래스 내 멤버변수와 이름이 동일한 매개변수를 사용할 수 있음.

또한 현재 객체의 정보를 this 포인터를 통해 반환할 수 있음.

## 클래스의 동적할당
### 생성자, 소멸자
클래스의 경우 생성자와 소멸자를 멤버 함수로 가진다.

별도로 구현하지 않아도 자동으로 생성되는 멤버함수 이다.
```
//MyType 클래스
public:
  MyType()  //생성자
  {
  }

  ~MyType()  //소멸자
  {
  }
```
1. 생성자 - 객체가 생성될 때 호출되는 함수.
2. 소멸자 - 객체가 소멸될 때 호출되는 함수.

### c와 c++의 차이
```
// c
MyType* pMyType1 = (MyType*)malloc(sizeof(MyType));
free(pMyType1);

// c++
MyType* pMyType2 = new MyType;
delete pMyType2;
```
- c 의 경우 단순하게 원하는 메모리의 크기만 전달하기 때문에 힙 메모리 공간에 할당되는 영역이 무슨 용도로 쓰일지까지 알 수 없음
    - 크기만 지정하고 해당 공간에 대한 용도는 모르기 때문에 C++의 클래스 규칙인 생성자와 소멸자 호출로 연계 X
- c++ 의 경우 동적할당에 사용할 자료형 정보를 전달한다. 자료형 정보를 통해서 크기 정보, 클래스 타입인 경우 클래스의 생성자 호출로 연계
    - delete의 경우 키워드에 포인터를 전달 시켜 포인터 타입에 따라 힙메모리 공간을 어떤 옹도로 쓰였는지 확인 > 소멸자 호출
 
### 여러개를 동적할당
```
MyType* pMyType3 = new MyType[4];
delete[] pMyType3;
```
생성의 경우 new 자료형 뒤에 배열처럼 크기를 넣어 몇개를 만들것인지 선언

해제의 경우 delete 뒤에 []를 붙여서 할당 해제한다.
