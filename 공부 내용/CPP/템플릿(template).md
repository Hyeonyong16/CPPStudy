# 템플릿 (template)
## 템플릿이란
매개 변수의 타입에 따라 함수나 클래스를 생성하는 매커니즘
- 여러가지 타입에서 동작하는 코드를 찍어내는 틀
- 템플릿 사용 시 다양한 타입에 대해 하나의 함수나 클래스만 정의하면 되므로 전체 코드를 간결하게 작성 가능

템플릿을 통하여 타입을 인자인것 처럼 사용하는 것을 일반화 프로그래밍(generic programming)이라 함

## 템플릿 정의 방법
### 함수 템플릿
```
template<typename T>
함수
{
  // 함수 내용
}
```
- typename T 에서 T는 타입의 이름으로 임의로 타입이름을 정해서 넣어줘도 된다.
- T(타입 이름)의 경우 함수 호출 시 전달된 매개변수에 따라 맞춰서 바뀐다.

#### 함수 템플릿 사용 예시
```
template<typename T>
T Add(T _a, T _b)
{
  return _a + _b;
}

int main()
{
  int a = 0;
  int b = 1;
  int sum = Add<int>(a, b);  // 최초 호출 시 int로 만들어진 함수를 컴파일러가 제작
  int a = Add<int>(sum, b);  // 여기선 새로 제작하지 않고 앞에서 int로 만들어진 함수를 호출
}
```
메인에서 Add<int>(a,b) 부분에서 컴파일러는 T를 int로 하는 함수를 하나 만든다.

템플릿 함수의 경우 매 호출 시 마다 함수를 만드는 것이 아닌 한번 만들어지면 다음부터는 만들어진 함수를 호출할 뿐 새로 만들지 않는다.

다른 자료형으로 템플릿 함수를 호출할 경우에는 만들어짐.

### 클래스 템플릿
```
// class 정의
template<typename T>
class CArray
{
  ~~~
}

// 함수 정의
template<typename T>
CArray<T>::CArray()
{
}

// 템플릿 클래스 선언
int main()
{
  CArray<int> arrI;
}
```
템플릿 클래스의 경우 헤더파일에 구현 내용을 작성해주어야 한다. (파일 분할 X)
- cpp 파일로 구현 내용 분할 시 컴파일 타임에 전방선언 정보만 있고 요청 시점에 구현 정보가 없어서 링크 불가능

1. 헤더파일은 컴파일 X, cpp 파일에 include 한 헤더 파일 내용이 복사
2. 각각 cpp 파일들이 독립적으로 컴파일 > 완료된 후 같은 프로젝트의 cpp 파일끼리 링킹
3. 컴파일 시 메모리 정의를 위해 구체적인 자료형을 알아야 하지만 템플릿 타입만 있어서 메모리에 정의되지 못하고 넘어감
4. 헤더파일로 인해 함수의 내용은 알기에 컴파일 에러는 X > 링킹 시 링킹 에러 발생

이로 인해 헤더파일에 선언 및 구현을 전부 작성해주는것이 좋다.
