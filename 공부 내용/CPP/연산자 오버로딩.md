# 연산자 오버로딩
## 연산자 오버로딩이란
기존에 존재하는 연산자를 재정의하여 다양하게 사용할 수 있게 해주는 방법

사용자가 임의로 만든 객체등에 대한 연산을 정의해서 객체끼리의 연산을 편하게 할 수 있다.

## 선언 방법
```
//반환타입 operator 연산자 (연산자가 받는 인자)
//{
//   return 반환값
//}

class CData
{
public:
    int        m_i;
    long long  m_ll;

    bool operator ==(int _Data) const
    {
        return m_i == _Data;
    }

    CData() : m_i(0), m_ll(0) {}
    CData(int input) : m_i(input), m_ll(0) {}
    ~CData() {}
}

bool operator ==(const int _Data, const CData& _i)
{
    return _Data == _i.m_i;
}

~~~~~
CData a(10);
int i = 10;
bool b;

b = (a==i);    // a.operator==(i)
b = (i==a);    // operator==(i, a)
```
다음과 같은 방식으로 전역함수, 클래스의 멤버 함수로 정의할 수 있다.

- 클래스의 멤버 함수로 정의
    - 연산자의 왼쪽에 있는 피연산자 객체가 해당 함수를 호출하는 경우
- 전역 함수로 정의
    - 객체가 연산자 뒤에 위치해도 정상적으로 연산 진행 ( ex - 10 + a)
 
## 연산자 오버로딩 제약
### 오버로딩이 불가능한 연산자
- . - 멤버 접근 연산자
-  .* - 멤버 포인터 연산자
- :: - 범위 지정 연산자
- ?: - 조건 연산자 (3항 연산자)
- sizeof - 크기 연산자
- typeid - 타입 인식
- const, dynamic, reinterpret, static_cast - 타입 변환

### 클래스 내에 멤버 함수로만 오버로딩할 수 있는 연산자
- = - 대입 연산자
- () - 함수 호출
- [] - 배열 인덱스
- -> - 멤버 접근 연산자

### 주의점
1. 기존 연산자에 추가적인 기능을 더하는 것만 가능하며 새로운 연산자를 정의하는 것은 불가능
2. 기본 타입을 다루는 연산자의 의미는 재정의 불가하다 - 연산자의 피연산자 중 최소 하나는 사용자 정의 타입이여야 함.
3. 연산자의 우선순위와 결합성은 바뀌지 않음
4. 매개변수의 디폴트값은 사용 불가
