# 구조체(Struct)

구조체를 한마디로 설명 시 **"사용자가 만드는 자료형"**

## 선언 및 초기화
```
// struct 구조체 이름
// { 멤버로 넣을 변수들 }
struct MyDataType
{
  // 멤버로 넣을 변수들
  char  c = 'B';
  int   i = 0;
  // ...
}

int main()
{
  // 구조체 이름 / 변수명 = { 초기화 값 }
  MyDataType data = { 'A', 10 };  //구조체 멤버 선언 순서대로 초기화
}
```
구조체를 사용할 함수보다 **상단**에 선언해야 함

구조체는 전방선언이 불가(포인트 사용할 시에는 가능)
1. 해당 구조체를 사용할 함수보다 뒤에 선언 시 해당 구조체로 할당할 메모리 크기를 모르기 때문에 컴파일 에러 발생
2. ㄴ 스택 메모리에 해당 구조체로 얼만큼 메모리를 할당할지 몰라서 발생
3. 해당 구조체를 포인터로 사용할 시에는 전방선언 가능(추후 포인터에서 추가)

초기값을 넣지 않아도 컴파일 됨(구조체 내부에서 초기값 설정 안하면 쓰레기값이 들어감)

## 구조체 각 멤버 접근 방법
```
// 앞에 선언한 data 변수에 접근
data.c = 'C';    // data의 c변수에 접근(MyDataType의 C)
data.i = 100;    // data의 i변수에 접근(MyDataType의 i)
```
함수에 선언한 **해당 구조체 변수명 + . + 접근할 멤버 변수명**으로 접근 가능

## 구조체 크기
구조체 크기는 구조체를 구성하는 요소들에 의해 정해짐

구조체 크기 정해지는 방법
1. 구조체가 포함하는 멤버중 가장 큰 값을 기준으로 그 값의 배수만큼 구조체 크기가 정해짐
2. CPU가 자료형을 저장할 때 효율을 위해 자료형 크기의 배수에 해당하는 주소에 위치

### 구조체가 포함하는 멤버 중 가장 큰 값
```
struct MyDataType
{
  char  c;        // 1 Byte
  int   i;        // 4 Byte
  char  cArr[5];  // 1 Byte * 5
}
```
다음 구조체에서 멤버의 크기 중 int 자료형이 가장 크기가 큼 > 구조체의 크기는 4의 배수

char 형 배열이 총 크기는 5 이지만 자료형 자체는 int가 더 크기 때문에 int 자료형 기준

### 자료형 크기의 배수에 해당하는 주소
위에서 선언한 MyDataType 구조체를 보면 가장 큰 자료형인 int이고 4의 배수이니

1 + 4 + (1 * 5) > 10 Byte > 10보다 큰 4의 배수이므로 12 Byte 일 것 같지만 16이 나옴
```
struct MyDataType
{
  char    c;        // 1 Byte
  short   s;        // 2 Byte
  int     i;        // 4 Byte
  char    cArr[5];  // 1 Byte * 5
}
```
1 Byte를 썻다고 바로 붙여서 다음 멤버를 붙여서 할당하지 않음

![image](https://github.com/Hyeonyong16/CPPStudy/assets/49775204/18bf1229-c326-40cd-b1e6-998150f1d6fd)

그림과 같이 CPU 는 자료형을 저장할 때 자료형 크기의 배수에 해당하는 주소에 각 자료형을 저장한다
1. 맨 앞(0)에 가장 먼저 선언한 char c 저장
2. 다음 멤버인 short의 경우 크기가 2 byte 이므로 1은 비우고 2의 배수인 2번에 저장
3. int i의 경우 short 뒤인 4에 저장
4. int i 뒤부터 배열의 크기인 5개의 메모리에 char cArr[5] 저장
5. 멤버중 가장 큰 자료형을 따라가니까 cArr[5] 뒤 3칸 padding

#### 바이트 패딩이 되는 이유
CPU가 접근하기 쉬운 위치에 컴파일러는 필드를 배치하는데 그로인해 빈공간이 들어가게 되고 이를 바이트 패딩이라 함.
네트워크를 통해서 구조체를 전송할 경우 운영체제와 컴파일러에 따라서 구조체가 정의되는 메모리의 형태가 달라져 문제가 생길 수 있음

```
#pragma pack(크기)
```
메모리에 데이터 저장을 크기만큼 저장

#pragma pack(1)을 사용할 경우 구조체가 멤버의 크기만큼 할당되는 것을 확인 가능

```
#pragma pack(push, 1)
//구조체
#pragma pack(pop)
```
기존의 바이트를 스택에 push하고 1 byte 단위로 처리 > 끝나는 부분에서 기존 byte 단위를 pop해주는 코드
