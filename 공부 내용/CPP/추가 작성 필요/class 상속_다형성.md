# class 상속
## 다형성
상속한 class 의 경우 한가지 타입으로 다양한 형태를 나타낼 수 있다.

### 상속 구조 + 포인터
```
class Parent { ~~~ };

class Child : public Parent { ~~~ };

int main()
{
  Parent p;
  Parent* pParent = &p;
  Child c;
  Child* pChild = &c;

  pParent = &c;
}
```
부모 클래스 포인터 타입 변수로 자식 클래스 객체의 주소를 받을 수 있다.

반대로 자식 클래스 포인터는 부모 클래스 객체를 포인터로 받을 수 없다.

- [  부모  ]
- [  부모  |  자식  ]

다음과 같이 메모리가 되어있어 부모로는 자식을 받을 수 있지만 자식이 부모를 받을 경우 할당된 메모리보다 뒤에 메모리도 참조하기 때문에 에러 발생

### 오버라이딩 + 다형성
```
class Parent
{
~~~
public:
  void Output() { cout << "Parent" << endl; }
};

class Child : public Parent
{
~~~
public:
  void Output() { cout << "Child" << endl; }
};

int main()
{
  Child c;
  Parent* pParent = nullptr;
  pParent = &c;

  pParent->Output();  // Parent
}
```
다음과 같이 부모 클래스의 포인터 변수로 자식 클래스 객체의 주소를 받아 함수를 호출할 시 오버라이딩한 자식 클래스의 함수가 아닌 부모클래스의 함수가 호출된다.
- 정적 바인딩: 코드를 실행하기 전에 어떤 함수가 불러질 지 결정
    - 위 코드에서는 Child의 Output이 아닌 Parent의 Output 함수를 호출

이 경우 가상 함수를 사용해서 부모 클래스의 함수가 아닌 오버라이딩한 자식 클래스의 함수가 호출되게 할 수 있다.
- 동적 바인딩

## 가상 함수 (Virtual Function)
### 가상 함수란
상속받은 자식 클래스에서 **재정의할 것** 으로 기대하고 정의해놓은 함수

정적 바인딩으로 인한 문제 상황을 해결하기 위해 virtual 을 사용한다.

### 가상 함수 선언
```
class Parent
{
~~~
  virtual void Output() { cout << "Parent" << endl; }
};

class Child : public Parent
{
~~~
  virtual void Output() override { cout << "Child" << endl; }
};
```
가상 함수 선언할 부모 클래스의 멤버 함수 앞에 virtual 키워드를 붙여 가상 함수 선언을 한다.

부모 클래스에 구현된 가상함수를 오버라이딩 하면 자식 쪽에서 오버라이딩한 함수도 가상함수로 취급된다.

부모 클래스의 가상함수를 오버라이딩한 경우에만 override 키워드를 붙일 수 있다.
- 해당 함수를 오버라이딩했다는 것을 알려주는 키워드
- 안붙여도 문제는 없지만 오버라이딩한 함수가 아닌데 붙일 경우 컴파일 에러가 발생한다.

### 순수 가상 함수
```
class Parent
{
~~~
  virtual void Output() = 0;
}
```
부모쪽에서 가상함수 선언 후 해당 함수를 구현하지 않고  = 0 을 붙이면 순수 가상 함수를 선언할 수 있다.

- 자식쪽에서는 해당 함수를 구현해야 한다 제시해준다.
  - 상속받은 자식 클래스에서 해당 함수를 무조건 재정의해야 한다.
- 순수 가상 함수가 포함되어 있는 클래스는 객체 선언이 불가능하다.

순수 가상 함수가 존재하는 클래스를 추상 클래스(abstract class)라고 한다.

### 가상 함수의 구동 원리
가상함수 선언 시 눈에 보이지 않는 가상함수 테이블 포인터 변수가 메모리 가장 앞에 추가된다.(포인터 변수이므로 8 바이트)
  - 시작주소(맨 앞)에 있어야 부모 포인터로 접근시에도 테이블 포인터 변수에 접근해 함수를 가져올 수 있다.

1. 각 객체 생성 시 가상함수 테이블 포인터는 각각의 가상함수 데이터가 저장된 곳의 주소를 받는다 (Type-info)
2. 부모 포인터로 접근하지만 가상함수 테이블에는 각 클래스의 가상함수 데이터가 저장된 곳의 주소로 가기 때문에 오버라이딩한 함수가 나온다(동적 바인딩)
3. 가상함수 테이블에는 각 가상함수 별로 인덱싱이 되어있다. > 오버라이딩을 했을 경우 본인 함수, 아닐경우 부모의 함수 호출.

### 추상 클래스
1. 순수 가상 함수를 포함하고 있는 클래스
2. 추상 클래스로는 객체 생성이 불가능하다.
3. 구체적인 객체로 만들 목적이 아닌 자식 클래스들에게 상속시킬 목적으로 만들어진 클래스
4. 자식 클래스가 구체화되기 위해서 꼭 구현해야하는 함수(순수 가상 함수)들을 제시

### 가상 소멸자
부모 클래스의 포인터로 자식 클래스 객체를 받은 경우 소멸자 호출 시 자식 클래스의 소멸자가 아닌 부모 클래스의 소멸자만 호출된다.

클래스 상속 시 소멸자를 가상 함수로 만들어서 해당 문제를 해결한다.

```
class AA
{~~~};

class BB : public AA
{~~~};

AA* p = new BB;
delete p;
```
위 코드에서 BB를 heap 메모리 영역에 생성했지만 AA* 로 가리키고 있다.

포인터가 부모타입이기 때문에 소멸시에는 AA 쪽 소멸자만 호출되고 BB쪽 소멸자는 호출되지 않는다.

소멸자를 가상함수로 만들어서 소멸자 호출을 자식부터 하게 만든다.
