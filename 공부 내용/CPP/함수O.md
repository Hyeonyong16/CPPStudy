# 함수

```
// 반환타입, 함수명, 입력 인자
int add (int _a, _b)
{
  return _a + _b;
}
```
반환타입이 void가 아닌 경우 값을 반환해줘야 함

메인 함수보다 앞에 선언을 해줘야 메인함수에서 사용 가능

```
int add (int, int);  // 전방 선언

int main()
{
}

int add (int _a, _b)
{
  return _a + _b;
}
```
메인 함수 앞에 이런 함수가 있다고 선언만 해준 후 메인 함수 뒤에 함수 구현 가능 (전방 선언)

## 재귀 함수
함수 내부에서 자기 자신을 다시 호출해서 수행하는 방식
```
int Fibonacci_Recursion(int _Input)  //피보나치 수열
{
	if (1 == _Input || 2 == _Input)    //1이나 2일경우 1반환
		return 1;

	return Fibonacci_Recursion(_Input - 1) + Fibonacci_Recursion(_Input - 2);  //재귀함수
}
```

탈출 조건을 정해놓고 함수 내부에서 함수를 실행해서 반복 

탈출 조건이 정확하지 않거나 정해지지 않을 경우 함수를 무한 반복하여 스택 오버플로우(stack overflow) 발생
1. 함수 내부에서 함수가 계속 호출되어 스택 메모리 영역을 초과하여 할당되어 발생

### 재귀함수 장점
1. 변수를 여럿 만들 필요가 없음
2. 반복문 사용을 줄여 코드가 간결해질 수 있음

### 재귀함수 단점
1. 지속적으로 함수를 호출하기 때문에 반복문보다 메모리를 많이 사용
2. 함수를 호출하고 복귀하기 위한 컨텍스트 스위칭 비용 발생
주로 최적화 문제(속도)

## 함수 오버로딩
함수명이 동일하여도 입력받는 인자의 차이로 함수 구분이 가능
```
int Add(int, int);
int Add(int, int, int);
int Add(int, float);

float Add(int, int); //반환형이 다른 경우에는 오버로딩 불가해서 에러 발생 
```
1. 입력 변수 타입
2. 입력 변수 개수
입력 인자 차이로 구분 가능
