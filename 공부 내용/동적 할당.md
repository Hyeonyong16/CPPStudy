# 동적 할당
## 동적 할당이란
프로그램 실행 시간 동안 사용할 메모리 공간을 할당하는 것 (프로그램 시작 시점에는 크기가 정해지지 않음)

메모리 공간 중 힙 영역에 공간을 할당해서 사용함
## 동적 할당 선언
```
// 자료형* 변수명 = (자료형*)malloc(크기);
int* pData = (int*)malloc(sizeof(int) * 5); // 20 크기의 메모리 공간 동적 할당

pData[0] = 10;  // *(pData + 0)
pData[1] = 20;  // *(pData + 1)
...
pData[4] = 50;  // *(pData + 4)
pData[5] = 60;  // 할당한 공간의 크기보다 뒤에 값을 넣음  (문제 발생)
```
할당 시 해당 포인터 변수는 동적 할당한 공간의 시작 메모리 주소를 반환

### malloc이 void* 반환하는 이유
동적 할당한 메모리를 어떤 용도로 사용할지 모르기 때문에 void* 로 반환

반환 후에는 캐스팅해서 해당 자료형으로 사용

### 문제점
1. 할당하지 않은 힙 메모리 영역까지 접근 (pData[5]) - 힙 손상 (Heap Corruption)
2. 할당한 힙 메모리 영역에 대한 반환이 이루어지지 않음 - 메모리 누수(Leak)

초과한 영역을 사용 시 다른 곳에서 동적할당 할 때는 해당 메모리 주소가 비어있는걸로 생각 > 해당 메모리에 접근해서 동적 할당을 할려 하여 malloc 이 터지는 경우도 존재

할당한 힙 영역에 대한 반환이 이루어지지 않아 메모리 누수가 발생함

### 해결법
```
// free(동적 할당한 변수이름)
free(pData);
```
free를 통해 동적 할당한 메모리 주소를 받아서 해제해 준다.

메모리를 할당만 하고 해제하지 않으면 컴퓨터 종료 전까지 해당 메모리를 계속 차지하게 된다.

동적 할당 후 더 이상 사용할 필요가 없다면 꼭 free 함수를 통해 메모리를 해제할 것

## 사용 예시 (동적 배열(가변 배열))
동적 할당을 통해 크기가 늘어나는 배열을 만들어 사용할 수 있다.

### 구조체
```
struct Array
{
  int*      pData;
  int       Limit;
  int       Current;
};
```
1. pData - 동적 할당할 주소
2. 배열의 현재 최대 크기
3. 배열을 현재 사용중인 수치

### 초기화
```
void Init(Array* _Arr)
{
  _Arr->Limit = 2;
  _Arr->Current = 0;
  _Arr->pData = (int*)malloc(sizeof(int) * _Arr->Limit);
}
```
1. 동적 배열의 기본 최대 크기 설정
2. 배열 생성 시 들어있는 값은 없으니 Current 값 0 설정
3. 동적 배열의 최대 크기만큼 pData 동적 할당

### 배열에 값 넣기
```
void Push(Array* _Arr, int _Data)
{
  // 현재 동적할당한 공간이 꽉 찬 경우
	if (_Arr->Limit <= _Arr->Current)
	{
		// 기존 Limit 의 2배를 동적할당한다
		int* pNewData = (int*)malloc(_Arr->Limit * 2 * sizeof(int));

		// 기존 공간의 데이터를 새로운 공간으로 이전
		for (int i = 0; i < _Arr->Current; ++i)
		{
			pNewData[i] = _Arr->pData[i];
		}
		
		// 기존 값을 새로운 공간으로 이동 후 기존 공간은 할당 해제
		free(_Arr->pData);

		// 새로운 공간을 가르킴
		_Arr->pData = pNewData;	

		// 늘어난 만큼 Limit 수치 갱신
		_Arr->Limit *= 2;		
	}

	_Arr->pData[_Arr->Current++] = _Data; 
}
```
1. 값 대입 시 현재 배열이 꽉 찼는지 확인.
2. 꽉 찼을 경우 현재 배열 크기의 2배로 동적 할당
3. 기존 배열의 값을 현재 생성한 메모리로 복사
4. 복사 후 기존 동적 할당한 메모리는 해제
5. 배열의 주소를 새로 생성하여 값을 옮겨준 공간을 가르킴
6. Limit 크기를 새로 늘어난 값으로 갱신
7. 공간이 꽉찬 상태가 아니라면 값을 배열 맨뒤에 추가

### 동적 할당 해제
```
void Release(Array* _Arr)
{
  free(_Arr->pData);

  _Arr->pData = nullptr;
  _Arr->Limit = 0;
  _Arr->Current = 0;
}
```
1. 동적 할당한 공간 free로 할당 해제
2. 할당 해제 후에도 해당 공간에 값 자체는 남아있기 때문에 nullptr 로 넣어줌
3. 최대 크기, 현재 값 0으로 초기화

값 복사 시 크기가 초과하면 이전 메모리 공간은 할당 해제하지만 마지막에 남아있는 메모리 공간은 해제하지 않음

그래서 동적 할당 해제해주는 함수를 생성해서 마지막에 해당 메모리 할당 해제를 실행해줌
### 사용 예시
```
int main()
{
	Array arr = { };
	Init(&arr);

	Push(&arr, 100);
	Push(&arr, 200);
	Push(&arr, 300);  // 새로 동적 할당 발생
	Push(&arr, 400);
	Push(&arr, 500);  // 새로 동적 할당 발생
	Push(&arr, 600);
	Push(&arr, 700);

	// 마지막에 프로그램 종료시에는 별도로 할당 해제가 발생하지 않음
	// Release 함수를 만들어서 할당 해제 해줌
	Release(&arr);

	return 0;
}
```
